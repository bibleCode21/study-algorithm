import { Concept } from '@/features/algorithm/types/algorithm';

export const concepts: Concept[] = [
    // 데이터 구조
    {
        id: 'array',
        title: 'Array (배열)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `배열은 데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조입니다. 같은 종류의 데이터를 효율적으로 관리하기 위해 사용되며, 같은 종류의 데이터를 순차적으로 저장합니다.

**배열의 장점:**
- 빠른 접근 가능: 첫 데이터의 위치에서 상대적인 위치로 데이터 접근(인덱스 번호로 접근)하여 O(1) 시간에 접근 가능

**배열의 단점:**
- 데이터 추가/삭제의 어려움: 미리 최대 길이를 지정해야 하며, 중간에 삽입/삭제 시 다른 요소들을 이동시켜야 함

**시간 복잡도:**
- **접근**: O(1) - 인덱스를 알고 있으면 메모리 주소를 직접 계산하여 즉시 접근 가능
- **검색**: O(n) - 최악의 경우 배열의 모든 요소를 순차적으로 확인해야 함
- **삽입/삭제 (끝)**: O(1) - 배열 끝에 추가/제거만 하면 됨
- **삽입/삭제 (중간/앞)**: O(n) - 삽입/삭제 위치 이후의 모든 요소를 이동시켜야 함

**공간 복잡도**: O(n) - n개의 요소를 저장하기 위해 n개의 메모리 공간이 필요

파이썬에서는 리스트 타입이 배열 기능을 제공하며, TypeScript/JavaScript에서는 배열(Array) 타입을 사용합니다.`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(n)',
            worst: 'O(n)',
        },
        spaceComplexity: 'O(n)',
        tags: ['배열', '선형 자료구조', '기초', '인덱스'],
    },
    {
        id: 'stack',
        title: 'Stack (스택)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `스택은 데이터를 제한적으로 접근할 수 있는 구조로, 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 자료구조입니다. 가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조입니다.

**스택의 특징:**
- LIFO(Last In, First Out): 마지막에 넣은 데이터를 가장 먼저 추출하는 데이터 관리 정책
- FILO(First In, Last Out): 처음에 넣은 데이터를 가장 마지막에 추출하는 데이터 관리 정책
- 큐: FIFO 정책
- 스택: LIFO 정책

**주요 기능:**
- push(): 데이터를 스택에 넣기
- pop(): 데이터를 스택에서 꺼내기

**스택 구조와 프로세스 스택:**
- 스택 구조는 프로세스 실행 구조의 가장 기본
- 함수 호출 시 프로세스 실행 구조를 스택과 비교해서 이해 필요
- 재귀 함수의 동작 방식이 스택 구조로 이해됨

**스택의 장점:**
- 구조가 단순해서, 구현이 쉽다
- 데이터 저장/읽기 속도가 빠르다

**스택의 단점 (일반적인 스택 구현시):**
- 데이터 최대 개수를 미리 정해야 한다 (파이썬의 경우 재귀 함수는 1000번까지만 호출이 가능함)
- 저장 공간의 낭비가 발생할 수 있음 (미리 최대 개수만큼 저장 공간을 확보해야 함)

**스택의 활용:**
- 컴퓨터 내부의 프로세스 구조의 함수 동작 방식
- 함수 호출 관리 (콜 스택)
- 역순 문자열 처리
- 괄호 검사
- 후위 표기법 계산
- DFS 알고리즘

**시간 복잡도:**
- **push/pop**: O(1) - 배열의 끝에서만 추가/제거하므로 인덱스 계산만 하면 되어 상수 시간
- **peek**: O(1) - 배열의 마지막 요소에 직접 접근하므로 상수 시간

**공간 복잡도**: O(n) - n개의 요소를 저장하기 위해 n개의 메모리 공간이 필요

스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적입니다.`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(1)',
            worst: 'O(1)',
        },
        spaceComplexity: 'O(n)',
        tags: ['스택', 'LIFO', 'FILO', '선형 자료구조', 'push', 'pop', '프로세스 스택'],
    },
    {
        id: 'queue',
        title: 'Queue (큐)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `큐는 줄을 서는 행위와 유사한 자료구조로, 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조입니다. 음식점에서 가장 먼저 줄을 선 사람이 제일 먼저 음식점에 입장하는 것과 동일한 원리입니다.

**큐의 특징:**
- FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식으로 스택과 꺼내는 순서가 반대
- Enqueue: 큐에 데이터를 넣는 기능
- Dequeue: 큐에서 데이터를 꺼내는 기능

**큐의 활용:**
- 멀티 태스킹을 위한 프로세스 스케줄링 방식 구현 (운영체제)
- BFS 알고리즘
- 작업 스케줄링
- 프린터 대기열
- 메시지 큐

**시간 복잡도:**
- **enqueue/dequeue**: O(1) - 배열의 끝에 추가하고 앞에서 제거하므로 상수 시간 (단, 배열 기반 구현 시 dequeue는 O(n)일 수 있음)
- **front**: O(1) - 배열의 첫 번째 요소에 직접 접근하므로 상수 시간

**공간 복잡도**: O(n) - n개의 요소를 저장하기 위해 n개의 메모리 공간이 필요

큐의 경우 특별히 언급되는 장단점보다는, 큐의 활용 예로 프로세스 스케줄링 방식을 함께 이해해두는 것이 좋습니다.`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(1)',
            worst: 'O(n)',
        },
        spaceComplexity: 'O(n)',
        tags: ['큐', 'FIFO', '선형 자료구조', 'Enqueue', 'Dequeue'],
    },
    {
        id: 'linked-list',
        title: 'Linked List (연결 리스트)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `연결 리스트(링크드 리스트)는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조입니다. 배열은 순차적으로 연결된 공간에 데이터를 나열하는 반면, 링크드 리스트는 각 노드가 다음 노드의 주소를 저장하여 연결됩니다.

**링크드 리스트 기본 구조와 용어:**
- **노드(Node)**: 데이터 저장 단위 (데이터값, 포인터)로 구성
- **포인터(pointer)**: 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간

**링크드 리스트의 장점:**
- 미리 데이터 공간을 할당하지 않아도 됨 (배열은 미리 데이터 공간을 할당해야 함)
- 동적 크기 조정이 용이함

**링크드 리스트의 단점:**
- 연결을 위한 별도 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음
- 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
- 중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요

**링크드 리스트의 종류:**
- **단일 연결 리스트 (Singly Linked List)**: 각 노드가 다음 노드만을 가리킴
- **이중 연결 리스트 (Doubly Linked List)**: 각 노드가 이전 노드와 다음 노드를 모두 가리킴 (양방향 탐색 가능)
- **원형 연결 리스트 (Circular Linked List)**: 마지막 노드가 첫 번째 노드를 가리킴

**시간 복잡도:**
- **접근/검색**: O(n) - 특정 위치의 노드를 찾기 위해 처음부터 순차적으로 탐색해야 함
- **삽입/삭제 (앞)**: O(1) - head 노드만 변경하면 됨
- **삽입/삭제 (중간/뒤)**: O(n) - 삽입/삭제할 위치까지 탐색해야 함

**공간 복잡도**: O(n) - n개의 노드를 저장하기 위해 n개의 메모리 공간이 필요 (각 노드는 데이터와 포인터를 포함)

TypeScript/JavaScript에서는 배열 타입이 링크드 리스트의 기능을 모두 지원하지만, 링크드 리스트의 원리와 구현을 이해하는 것은 중요합니다.`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(n)',
            worst: 'O(n)',
        },
        spaceComplexity: 'O(n)',
        tags: ['연결 리스트', '노드', '포인터', '선형 자료구조', '단일 연결 리스트', '이중 연결 리스트'],
    },
    {
        id: 'heap',
        title: 'Heap (힙)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `힙은 완전 이진 트리 기반의 우선순위 큐 자료구조입니다. 최소 힙에서는 부모 노드가 항상 자식 노드보다 작거나 같고, 최대 힙에서는 부모 노드가 항상 자식 노드보다 크거나 같습니다. 힙 정렬, 우선순위 큐 구현 등에 사용됩니다.

**시간 복잡도:**
- **삽입**: O(log n) - 힙의 마지막 위치에 추가한 후, 힙 속성을 유지하기 위해 부모 노드와 비교하며 위로 올라가므로 트리의 높이만큼 비교 (완전 이진 트리의 높이는 log n)
- **삭제 (최소/최대값 제거)**: O(log n) - 루트 노드를 제거한 후, 마지막 노드를 루트로 옮기고 힙 속성을 유지하기 위해 자식 노드와 비교하며 아래로 내려가므로 트리의 높이만큼 비교
- **최소/최대값 접근**: O(1) - 루트 노드에 직접 접근하므로 상수 시간

**공간 복잡도**: O(n) - n개의 요소를 저장하기 위해 n개의 메모리 공간이 필요`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(log n)',
            worst: 'O(log n)',
        },
        spaceComplexity: 'O(n)',
        tags: ['힙', '이진 트리', '우선순위 큐', '힙 정렬'],
    },
    {
        id: 'hash-table',
        title: 'Hash Table (해시 테이블)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `해시 테이블은 키-값 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 키를 인덱스로 변환합니다. 평균적으로 O(1) 시간에 삽입, 삭제, 검색이 가능합니다. 충돌 해결 방법으로는 체이닝과 개방 주소법이 있습니다.

**시간 복잡도:**
- **삽입/삭제/검색 (평균)**: O(1) - 해시 함수로 인덱스를 계산하여 직접 접근하므로 상수 시간
- **삽입/삭제/검색 (최악)**: O(n) - 모든 키가 같은 해시값을 가져 충돌이 발생하는 경우, 체이닝 방식에서는 연결 리스트를 순차 탐색해야 함

**공간 복잡도**: O(n) - n개의 키-값 쌍을 저장하기 위해 n개의 메모리 공간이 필요 (버킷 배열의 크기는 구현에 따라 다를 수 있음)`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(1)',
            worst: 'O(n)',
        },
        spaceComplexity: 'O(n)',
        tags: ['해시 테이블', '해시 맵', '해시 함수', '충돌 해결'],
    },
    {
        id: 'tree',
        title: 'Tree (트리)',
        type: 'data-structure',
        category: ['데이터 구조'],
        description: `트리는 노드들이 계층적으로 연결된 비선형 자료구조입니다. 이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리이며, 이진 탐색 트리(BST)는 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큰 값을 가집니다. 전위, 중위, 후위, 레벨 순회 방법이 있습니다.

**시간 복잡도 (이진 탐색 트리 기준):**
- **삽입/삭제/검색 (평균)**: O(log n) - 각 단계마다 탐색 범위가 절반씩 줄어들므로 트리의 높이만큼 비교 (균형 트리의 높이는 log n)
- **삽입/삭제/검색 (최악)**: O(n) - 트리가 한쪽으로 치우쳐 선형 구조가 된 경우, 모든 노드를 순차 탐색해야 함
- **순회**: O(n) - 모든 노드를 한 번씩 방문해야 하므로 노드 개수만큼의 시간이 필요

**공간 복잡도**: O(n) - n개의 노드를 저장하기 위해 n개의 메모리 공간이 필요`,
        timeComplexity: {
            best: 'O(log n)',
            average: 'O(log n)',
            worst: 'O(n)',
        },
        spaceComplexity: 'O(n)',
        tags: ['트리', '이진 트리', '이진 탐색 트리', 'BST', '트리 순회'],
    },
    // 알고리즘
    {
        id: 'bubble-sort',
        title: 'Bubble Sort (버블 정렬)',
        type: 'algorithm',
        category: ['정렬'],
        description: `버블 정렬은 인접한 두 요소를 비교하여 순서가 잘못된 경우 교환하는 방식으로 동작하는 간단한 정렬 알고리즘입니다. 구현이 쉽지만 시간 복잡도가 높아 실제로는 거의 사용되지 않습니다.

**시간 복잡도:**
- **최선**: O(n) - 이미 정렬된 배열의 경우, 한 번의 순회로 정렬 완료를 확인하고 종료
- **평균/최악**: O(n²) - 이중 반복문으로 모든 요소를 비교하므로 n × n번의 비교가 필요

**공간 복잡도**: O(1) - 입력 배열 외에 추가 메모리 공간을 사용하지 않음 (제자리 정렬)`,
        timeComplexity: {
            best: 'O(n)',
            average: 'O(n²)',
            worst: 'O(n²)',
        },
        spaceComplexity: 'O(1)',
        tags: ['정렬', '버블 정렬', '기초'],
    },
    {
        id: 'binary-search',
        title: 'Binary Search (이진 탐색)',
        type: 'algorithm',
        category: ['탐색'],
        description: `이진 탐색은 정렬된 배열에서 특정 값을 효율적으로 찾는 알고리즘입니다. 배열의 중간값과 비교하여 탐색 범위를 절반씩 줄여나가며 O(log n) 시간에 탐색을 완료합니다.

**시간 복잡도:**
- **최선**: O(1) - 첫 번째 비교에서 바로 찾는 경우
- **평균/최악**: O(log n) - 각 단계마다 탐색 범위가 절반씩 줄어들므로, n개의 요소에서 log₂n번의 비교가 필요

**공간 복잡도**: O(1) - 반복문 구현 시 추가 메모리 공간을 사용하지 않음 (재귀 구현 시 O(log n)의 스택 공간 필요)`,
        timeComplexity: {
            best: 'O(1)',
            average: 'O(log n)',
            worst: 'O(log n)',
        },
        spaceComplexity: 'O(1)',
        tags: ['탐색', '이진 탐색', '분할 정복'],
    },
];
