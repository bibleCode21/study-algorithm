import { CodeAnnotation } from '../codeAnnotations';

// 각 코드 예제별 해석 배열
export const stackAnnotations: Record<string, CodeAnnotation[][]> = {
  typescript: [
    // 첫 번째 예제: 기본 스택 구현
    [
      {
        line: 7,
        comment:
          'Stack 클래스 정의: 제네릭 타입 T를 사용하여 다양한 타입의 데이터를 저장할 수 있습니다. LIFO(Last-In, First-Out) 구조를 구현합니다.',
      },
      {
        line: 8,
        comment:
          'items 배열: 스택의 데이터를 저장하는 내부 배열입니다. private으로 선언하여 외부에서 직접 접근할 수 없도록 캡슐화합니다.',
      },
      {
        line: 10,
        comment:
          '생성자: 선택적 파라미터를 받아 초기값을 설정할 수 있습니다. 파라미터가 없으면 빈 스택으로 시작합니다.',
      },
      {
        line: 17,
        comment:
          'push 메서드: 스택의 맨 위에 데이터를 추가합니다. 배열의 push 메서드를 사용하여 O(1) 시간에 추가할 수 있습니다.',
      },
      {
        line: 22,
        comment:
          'pop 메서드: 스택의 맨 위에서 데이터를 제거하고 반환합니다. 배열의 pop 메서드를 사용하여 O(1) 시간에 제거할 수 있습니다.',
      },
      {
        line: 27,
        comment:
          'peek 메서드: 스택의 맨 위에 있는 데이터를 확인합니다. 데이터를 제거하지 않고 단순히 확인만 하므로 O(1) 시간이 소요됩니다.',
      },
      {
        line: 31,
        comment:
          'isEmpty 메서드: 스택이 비어있는지 확인합니다. 배열의 길이가 0인지 확인하여 O(1) 시간에 판단할 수 있습니다.',
      },
      {
        line: 35,
        comment:
          'size 메서드: 스택에 저장된 데이터의 개수를 반환합니다. 배열의 길이를 반환하므로 O(1) 시간이 소요됩니다.',
      },
    ],
    // 두 번째 예제: 재귀 함수와 프로세스 스택
    [
      {
        line: 3,
        comment:
          'recursive 함수: 재귀 함수를 정의합니다. 함수 호출이 스택 구조로 관리되는 것을 보여주는 예제입니다.',
      },
      {
        line: 4,
        comment:
          '기저 조건: data < 0이면 재귀를 종료합니다. 이 조건이 없으면 무한 재귀가 발생합니다.',
      },
      {
        line: 5,
        comment:
          '종료 메시지: 재귀가 끝났을 때 출력되는 메시지입니다. 가장 깊은 재귀 호출에서 먼저 출력됩니다.',
      },
      {
        line: 7,
        comment:
          '현재 값 출력: 함수가 호출될 때마다 현재 data 값을 출력합니다. 재귀 호출 전에 실행되므로 4, 3, 2, 1, 0 순서로 출력됩니다.',
      },
      {
        line: 8,
        comment:
          '재귀 호출: recursive(data - 1)을 호출하여 다음 단계로 진행합니다. 이 호출이 스택에 쌓입니다.',
      },
      {
        line: 9,
        comment:
          '반환 후 출력: 재귀 호출이 반환된 후에 실행됩니다. 스택에서 함수가 제거될 때 실행되므로 0, 1, 2, 3, 4 순서로 출력됩니다.',
      },
    ],
    // 세 번째 예제: 리스트를 이용한 스택 구현
    [
      {
        line: 4,
        comment:
          'stackList 배열: 스택의 데이터를 저장하는 전역 배열입니다. 클래스 없이 간단하게 스택을 구현합니다.',
      },
      {
        line: 7,
        comment:
          'push 함수: 스택에 데이터를 추가하는 함수입니다. 배열의 push 메서드를 사용하여 O(1) 시간에 추가합니다.',
      },
      {
        line: 12,
        comment:
          'pop 함수: 스택에서 데이터를 제거하고 반환하는 함수입니다. 배열의 pop 메서드를 사용하여 O(1) 시간에 제거합니다.',
      },
      {
        line: 17,
        comment:
          '반복문으로 데이터 추가: 0부터 9까지 10개의 데이터를 스택에 추가합니다. 마지막에 추가된 데이터가 가장 위에 있습니다.',
      },
      {
        line: 21,
        comment:
          '스택 크기 확인: length 속성을 사용하여 스택에 저장된 데이터의 개수를 확인합니다.',
      },
      {
        line: 23,
        comment:
          'LIFO 동작 확인: pop()을 호출하면 가장 나중에 추가된 요소(9)가 먼저 제거됩니다. 이것이 LIFO 구조의 특징입니다.',
      },
    ],
    // 네 번째 예제: pop, push 기능 직접 구현
    [
      {
        line: 4,
        comment:
          'stackList 배열: 스택의 데이터를 저장하는 전역 배열입니다. push와 pop 메서드를 직접 구현합니다.',
      },
      {
        line: 7,
        comment:
          'push 함수 직접 구현: stackList[stackList.length] = data를 사용하여 배열의 끝에 데이터를 추가합니다. push 메서드와 동일한 동작입니다.',
      },
      {
        line: 12,
        comment:
          'pop 함수 직접 구현: 배열의 마지막 요소를 가져온 후, 배열의 길이를 줄여서 마지막 요소를 제거합니다.',
      },
      {
        line: 15,
        comment:
          '마지막 요소 가져오기: stackList[stackList.length - 1]을 사용하여 배열의 마지막 요소에 접근합니다.',
      },
      {
        line: 16,
        comment:
          '배열 길이 줄이기: stackList.length = stackList.length - 1을 사용하여 배열의 길이를 줄입니다. 이렇게 하면 마지막 요소가 제거됩니다.',
      },
      {
        line: 21,
        comment:
          '반복문으로 데이터 추가: 0부터 9까지 10개의 데이터를 스택에 추가합니다.',
      },
      {
        line: 27,
        comment:
          'LIFO 동작 확인: pop()을 호출하면 가장 나중에 추가된 요소가 먼저 제거됩니다. 직접 구현한 함수도 동일하게 동작합니다.',
      },
    ],
  ],
};

