import { CodeAnnotation } from '../codeAnnotations';

// 각 코드 예제별 해석 배열
export const heapAnnotations: Record<string, CodeAnnotation[][]> = {
  typescript: [
    // 첫 번째 예제: 힙 기본 개념 (1-28줄)
    [
      {
        line: 1,
        comment:
          '힙 개념: 힙은 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리입니다. 완전 이진 트리는 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리입니다.',
      },
      {
        line: 5,
        comment:
          '힙과 배열의 관계: 힙은 배열로 표현할 수 있습니다. 배열 인덱스 0부터 시작하는 경우, 부모와 자식 노드의 인덱스 관계가 명확하게 정의됩니다.',
      },
      {
        line: 6,
        comment:
          '부모 인덱스 계산: 자식 노드의 인덱스로부터 부모 노드의 인덱스를 계산하는 공식입니다. Math.floor((자식 인덱스 - 1) / 2)를 사용합니다.',
      },
      {
        line: 7,
        comment:
          '왼쪽 자식 인덱스 계산: 부모 노드의 인덱스로부터 왼쪽 자식 노드의 인덱스를 계산합니다. 부모 인덱스 * 2 + 1이 왼쪽 자식 인덱스입니다.',
      },
      {
        line: 8,
        comment:
          '오른쪽 자식 인덱스 계산: 부모 노드의 인덱스로부터 오른쪽 자식 노드의 인덱스를 계산합니다. 부모 인덱스 * 2 + 2가 오른쪽 자식 인덱스입니다.',
      },
      {
        line: 11,
        comment:
          'parent 함수: 자식 노드의 인덱스로부터 부모 노드의 인덱스를 반환하는 헬퍼 함수입니다. 힙 연산에서 자주 사용됩니다.',
      },
      {
        line: 15,
        comment:
          'leftChild 함수: 부모 노드의 인덱스로부터 왼쪽 자식 노드의 인덱스를 반환하는 헬퍼 함수입니다.',
      },
      {
        line: 19,
        comment:
          'rightChild 함수: 부모 노드의 인덱스로부터 오른쪽 자식 노드의 인덱스를 반환하는 헬퍼 함수입니다.',
      },
    ],
    // 두 번째 예제: 최대 힙 구현 (삽입) (1-54줄)
    [
      {
        line: 4,
        comment:
          'MaxHeap 클래스 정의: 최대 힙을 구현하는 클래스입니다. 각 노드의 값은 자식 노드의 값보다 크거나 같아야 합니다.',
      },
      {
        line: 5,
        comment:
          'heap 배열: 힙의 데이터를 저장하는 내부 배열입니다. 완전 이진 트리를 배열로 표현합니다.',
      },
      {
        line: 8,
        comment:
          'parent 메서드: 자식 노드의 인덱스로부터 부모 노드의 인덱스를 반환하는 헬퍼 메서드입니다.',
      },
      {
        line: 13,
        comment:
          'moveUp 메서드: 삽입한 노드가 부모 노드보다 큰지 확인합니다. 최대 힙에서는 부모가 자식보다 작으면 위치를 교환해야 합니다.',
      },
      {
        line: 14,
        comment:
          '루트 노드 체크: insertedIdx가 0 이하면 루트 노드이므로 더 이상 올라갈 수 없습니다. false를 반환하여 교환을 중단합니다.',
      },
      {
        line: 18,
        comment:
          '부모 노드와 비교: 삽입한 노드의 값이 부모 노드의 값보다 크면 true를 반환하여 교환이 필요함을 나타냅니다.',
      },
      {
        line: 27,
        comment:
          'insert 메서드: 힙에 새로운 데이터를 삽입합니다. 배열의 끝에 추가한 후, 힙 속성을 유지하기 위해 위로 올라가며 교환합니다. O(log n) 시간이 소요됩니다.',
      },
      {
        line: 28,
        comment:
          '배열 끝에 추가: push 메서드를 사용하여 배열의 끝에 새 데이터를 추가합니다. 이는 완전 이진 트리의 마지막 위치에 노드를 추가하는 것과 같습니다.',
      },
      {
        line: 32,
        comment:
          '힙 속성 유지: moveUp이 true를 반환하는 동안 부모 노드와 위치를 교환합니다. 이 과정을 통해 최대 힙의 속성을 유지합니다.',
      },
      {
        line: 34,
        comment:
          '구조 분해 할당으로 교환: 배열의 두 요소를 한 번에 교환합니다. [a, b] = [b, a] 형태로 두 값을 교환합니다.',
      },
    ],
    // 세 번째 예제: 최대 힙 데이터 삭제 구현 (1-131줄)
    [
      {
        line: 11,
        comment:
          'leftChild 메서드: 부모 노드의 인덱스로부터 왼쪽 자식 노드의 인덱스를 반환하는 헬퍼 메서드입니다.',
      },
      {
        line: 16,
        comment:
          'rightChild 메서드: 부모 노드의 인덱스로부터 오른쪽 자식 노드의 인덱스를 반환하는 헬퍼 메서드입니다.',
      },
      {
        line: 21,
        comment:
          'moveDown 메서드: root 노드가 자식 노드보다 작은지 확인합니다. 최대 힙에서는 자식이 부모보다 크면 위치를 교환해야 합니다.',
      },
      {
        line: 26,
        comment:
          'case1: 자식이 없는 경우: 왼쪽 자식 인덱스가 배열 길이를 초과하면 자식이 없는 리프 노드입니다. 더 이상 내려갈 수 없으므로 false를 반환합니다.',
      },
      {
        line: 30,
        comment:
          'case2: 왼쪽 자식만 있는 경우: 오른쪽 자식 인덱스가 배열 길이를 초과하면 왼쪽 자식만 있습니다. 왼쪽 자식과 비교하여 교환이 필요한지 확인합니다.',
      },
      {
        line: 38,
        comment:
          'case3: 양쪽 자식이 모두 있는 경우: 왼쪽과 오른쪽 자식을 비교하여 더 큰 자식과 부모를 비교합니다. 더 큰 자식이 부모보다 크면 교환이 필요합니다.',
      },
      {
        line: 59,
        comment:
          'pop 메서드: 힙에서 최대값을 제거하고 반환합니다. root 노드를 제거한 후, 마지막 노드를 root로 이동시키고 힙 속성을 유지하기 위해 아래로 내려가며 교환합니다. O(log n) 시간이 소요됩니다.',
      },
      {
        line: 64,
        comment:
          '단일 노드 체크: 힙에 노드가 하나만 있으면 바로 제거하고 반환합니다. 추가 처리가 필요 없습니다.',
      },
      {
        line: 68,
        comment:
          'root 값 저장: 제거할 root 노드의 값을 미리 저장합니다. 이 값이 반환될 최대값입니다.',
      },
      {
        line: 69,
        comment:
          '마지막 노드를 root로 이동: 배열의 마지막 요소를 root 위치로 이동시킵니다. 이렇게 하면 힙의 크기가 줄어들고, 힙 속성을 다시 유지해야 합니다.',
      },
      {
        line: 74,
        comment:
          '힙 속성 유지: moveDown이 true를 반환하는 동안 자식 노드와 위치를 교환합니다. 이 과정을 통해 최대 힙의 속성을 유지합니다.',
      },
    ],
    // 네 번째 예제: 최대 힙 완전 구현 (1-103줄)
    [
      {
        line: 4,
        comment:
          'MaxHeap 클래스: 완전한 최대 힙 구현입니다. 모든 기본 연산(삽입, 삭제, 조회)을 지원합니다.',
      },
      {
        line: 29,
        comment:
          'swap 메서드: 두 인덱스의 요소를 교환하는 헬퍼 메서드입니다. 구조 분해 할당을 사용하여 간결하게 구현합니다.',
      },
      {
        line: 34,
        comment:
          'heapifyUp 메서드: 힙 속성을 위로 올라가며 유지합니다. 부모 노드가 자식 노드보다 작으면 교환하고, 루트에 도달할 때까지 반복합니다.',
      },
      {
        line: 35,
        comment:
          '힙 속성 확인: index > 0이고 부모 노드의 값이 현재 노드의 값보다 작으면 교환이 필요합니다. 최대 힙에서는 부모가 자식보다 크거나 같아야 합니다.',
      },
      {
        line: 42,
        comment:
          'heapifyDown 메서드: 힙 속성을 아래로 내려가며 유지합니다. 재귀적으로 호출하여 힙 속성을 완전히 복원합니다.',
      },
      {
        line: 43,
        comment:
          'largest 변수: 현재 노드와 자식 노드 중 가장 큰 값을 가진 노드의 인덱스를 저장합니다. 초기값은 현재 노드의 인덱스입니다.',
      },
      {
        line: 47,
        comment:
          '왼쪽 자식 비교: 왼쪽 자식이 존재하고 현재 largest보다 크면 largest를 왼쪽 자식으로 업데이트합니다.',
      },
      {
        line: 51,
        comment:
          '오른쪽 자식 비교: 오른쪽 자식이 존재하고 현재 largest보다 크면 largest를 오른쪽 자식으로 업데이트합니다.',
      },
      {
        line: 55,
        comment:
          '교환 및 재귀: largest가 현재 인덱스와 다르면 교환이 필요합니다. 교환한 후 재귀적으로 heapifyDown을 호출하여 하위 트리의 힙 속성도 유지합니다.',
      },
      {
        line: 62,
        comment:
          'insert 메서드: 힙에 요소를 추가합니다. 배열 끝에 추가한 후 heapifyUp을 호출하여 힙 속성을 유지합니다. O(log n) 시간이 소요됩니다.',
      },
      {
        line: 68,
        comment:
          'pop 메서드: 힙에서 최대값을 제거하고 반환합니다. root를 마지막 요소로 교환한 후 heapifyDown을 호출하여 힙 속성을 유지합니다. O(log n) 시간이 소요됩니다.',
      },
      {
        line: 79,
        comment:
          'peek 메서드: 힙의 최대값을 확인합니다. root 노드의 값을 반환하므로 O(1) 시간이 소요됩니다. 데이터를 제거하지 않습니다.',
      },
    ],
    // 다섯 번째 예제: 최소 힙 구현 (1-102줄)
    [
      {
        line: 1,
        comment:
          'MinHeap 클래스: 최소 힙을 구현하는 클래스입니다. 각 노드의 값은 자식 노드의 값보다 작거나 같아야 합니다. MaxHeap과 반대의 속성을 가집니다.',
      },
      {
        line: 35,
        comment:
          'heapifyUp 메서드 (최소 힙): 부모 노드가 자식 노드보다 크면 교환합니다. 최소 힙에서는 부모가 자식보다 작거나 같아야 합니다.',
      },
      {
        line: 36,
        comment:
          '힙 속성 확인 (최소 힙): 부모 노드의 값이 현재 노드의 값보다 크면 교환이 필요합니다. 최소 힙에서는 부모가 자식보다 작거나 같아야 합니다.',
      },
      {
        line: 43,
        comment:
          'heapifyDown 메서드 (최소 힙): 자식 노드 중 가장 작은 값을 가진 노드와 비교하여 교환합니다. smallest 변수를 사용하여 최소값을 추적합니다.',
      },
      {
        line: 48,
        comment:
          '왼쪽 자식 비교 (최소 힙): 왼쪽 자식이 존재하고 현재 smallest보다 작으면 smallest를 왼쪽 자식으로 업데이트합니다.',
      },
      {
        line: 52,
        comment:
          '오른쪽 자식 비교 (최소 힙): 오른쪽 자식이 존재하고 현재 smallest보다 작으면 smallest를 오른쪽 자식으로 업데이트합니다.',
      },
      {
        line: 63,
        comment:
          'insert 메서드: 최소 힙에 요소를 추가합니다. MaxHeap과 동일한 방식이지만 heapifyUp에서 최소 힙 속성을 유지합니다.',
      },
      {
        line: 69,
        comment:
          'extractMin 메서드: 최소 힙에서 최소값을 제거하고 반환합니다. MaxHeap의 pop 메서드와 동일한 로직이지만 최소값을 반환합니다.',
      },
      {
        line: 80,
        comment:
          'peek 메서드: 최소 힙의 최소값을 확인합니다. root 노드의 값을 반환하므로 O(1) 시간이 소요됩니다.',
      },
    ],
  ],
};
